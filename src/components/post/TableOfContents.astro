---
import { type MarkdownHeading } from "astro";
import { toStyleVars } from "@/lib/utils";
import Link from "@/components/common/Link.astro";
import type { StyledProps } from "@/types";

interface Props extends StyledProps {
  headings: MarkdownHeading[];
}

const { class: className, style: styleAttr, headings } = Astro.props;
---

<table-of-contents>
  <div id="toc-wrapper" class:list={[className]} style={styleAttr}>
    <ul class="mx-4 py-2">
      {
        headings.map((heading) => (
          <li class="text-foreground/50 hover:text-accent not-first:mt-1">
            <Link
              href={`#${heading.slug}`}
              class:list={["btn justify-start px-2 py-0.5"]}
              data-variant="ghost"
            >
              <span
                class:list={["pl-[calc(var(--depth)_*_0.7)]"]}
                style={toStyleVars({ depth: heading.depth - 1 })}
              >
                {heading.text}
              </span>
            </Link>
          </li>
        ))
      }
    </ul>
    <div
      id="viewport-indicator"
      class:list={[
        "bg-accent rounded-surface absolute left-0 -z-10 w-1 transition-[height,top] duration-100",
      ]}
    >
    </div>
  </div>
</table-of-contents>

<script>
  interface Section {
    id: string;
    start: number;
    end: number;
  }

  class TableOfContent extends HTMLElement {
    mdSections: Section[] = [];
    tocSections: Section[] = [];
    tocElements: HTMLElement[] = [];
    tocWrapperElement: HTMLElement | null = null;
    viewportIndicator: HTMLElement | null = null;
    scrollYOffset = 480;

    constructor() {
      super();
    }

    getViewportHeight() {
      const top = window.scrollY;
      const bottom = top + window.innerHeight;

      return { top, bottom };
    }

    getVisibleSectionsIndex() {
      const { top, bottom } = this.getViewportHeight();

      // this code will loop more as the page scrolls down
      let visibleSectionIdx = [];
      for (const [index, heading] of this.mdSections.entries()) {
        const start = heading.start;
        const end = heading.end;
        if (start > bottom) break;
        if (end >= top && start <= bottom) visibleSectionIdx.push(index);
      }

      return visibleSectionIdx;
    }

    buildSectionOffset(elements: HTMLElement[]) {
      return elements
        .map((el, index) => {
          const end =
            elements.length > index + 1
              ? elements[index + 1].offsetTop
              : el.offsetTop + el.offsetHeight;
          return {
            id: el.id,
            start: el.offsetTop,
            end: end,
          };
        })
        .sort((a, b) => a.start - b.start);
    }

    buildSection() {
      const headingElements = Array.from(
        document.querySelectorAll<HTMLElement>(
          ".prose :where(h1, h2, h3, h4, h5, h6)",
        ),
      );
      const tocHeadingElements = Array.from(
        document.querySelectorAll<HTMLElement>(
          "#toc-wrapper ul li:has(a[href^='#'])",
        ),
      );

      this.mdSections = this.buildSectionOffset(headingElements);
      this.tocSections = this.buildSectionOffset(tocHeadingElements);
      this.tocElements = tocHeadingElements;
    }

    updateIndicator() {
      if (this.mdSections.length === 0) return [];
      const visibleSectionIdx = this.getVisibleSectionsIndex();
      const length = visibleSectionIdx.length;

      const startIdx = visibleSectionIdx[0];
      const endIdx = visibleSectionIdx[length - 1];

      const top = this.tocSections[startIdx].start;
      const bottom = this.tocSections[endIdx].end;

      this.viewportIndicator?.setAttribute(
        "style",
        `top: ${top}px; height: ${bottom - top}px`,
      );

      this.tocElements.forEach((el, index) => {
        if (visibleSectionIdx.includes(index)) {
          el.classList.add("text-foreground/80");
        } else {
          el.classList.remove("text-foreground/80");
        }
      });

      this.tocWrapperElement?.scrollTo({
        top: top * 0.87,
        left: 0,
        behavior: "smooth",
      });
    }

    handleScroll = () => {
      this.updateIndicator();
    };

    handleResize = () => {
      this.buildSection();
      this.updateIndicator();
    };

    connectedCallback() {
      this.buildSection();

      this.tocWrapperElement = document.querySelector("#toc-wrapper");
      this.viewportIndicator = document.querySelector("#viewport-indicator");

      window.addEventListener("scroll", this.handleScroll, { passive: true });
      window.addEventListener("resize", this.handleResize, { passive: true });

      this.updateIndicator();
    }

    disconnectedCallback() {
      window.removeEventListener("scroll", this.handleScroll);
      window.removeEventListener("resize", this.handleResize);
    }
  }

  if (!customElements.get("table-of-contents")) {
    customElements.define("table-of-contents", TableOfContent);
  }
</script>
